= SmallRye Health in Quarkus
ifndef::imagesdir[:imagesdir: images]

SmallRye Health allows applications to provide information about their state to external viewers which is typically useful in cloud environments where automated processes must be able to determine whether the application should be discarded or restarted.

*In this instruction, i will show you how to use it in Quarkus.*

== Prerequisites
To complete this guide, you need:

* Roughly 15 minutes
* An IDE
* JDK 17+ installed with JAVA_HOME configured appropriately
* Apache Maven 3.9.8
* Optionally the Quarkus CLI if you want to use it
* Optionally Mandrel or GraalVM installed and configured appropriately if you want to build a native executable (or Docker if you use a native container build)

== Creating the Maven Project

image::create-project.png[]

=== SmallRye Health extension

* _in Wizard:_

image::required-extensions.png[]

* _or add to existing project:_

.Quarkus-CLI
[source, bash]
----
quarkus ext add io.quarkus:quarkus-smallrye-health
----

.Maven-Wrapper
[source, bash]
----
./mvnw quarkus:add-extension -Dextensions="io.quarkus:quarkus-smallrye-health"
----

.pom.xml
[source, xml]
----
<dependency>
    <groupId>io.quarkus</groupId>
    <artifactId>quarkus-smallrye-health</artifactId>
</dependency>
----

== First attempts

=== Start the project

.Quarkus-CLI
[source, bash]
----
quarkus dev --clean
----

.Maven-Wrapper
[source, bash]
----
./mvnw clean quarkus:dev
----

=== Existing health checks endpoints

Importing the smallrye-health extension directly exposes three REST endpoints:

* link:localhost:8080/q/health/live[`/q/health/live`] - The application is up and running.
* link:localhost:8080/q/health/ready[`/q/health/ready`] - The application is ready to serve requests.
* link:localhost:8080/q/health/started[`/q/health/started`] - The application is started.
* link:localhost:8080/q/health[`/q/health`] - Accumulating all health check procedures in the application.

All health REST endpoints return a simple JSON object with two fields:

* `status` - the overall result of all the health check procedures

* `checks` - an array of individual checks

=== Use existing health checks endpoints

.Example: Accumulating all health check procedures in the application
[source, bash]
----
curl http://localhost:8080/q/health/live
----

.Response of /q/health/live
[source, json]
----
{
    "status": "UP",
    "checks": [
    ]
}
----

*Now try it yourself with the other existing endpoints :-)*

== Individual Health Checks

You can also create your own health checks to announce the availability of your own program parts using own health check classes.

=== Liveness-Check

==== Create class `LivenessCheck`

image::create-class-livenesscheck.png[]

==== Implement class `LivenessCheck`

[source,java]
----
package at.htlleonding.health;

import jakarta.enterprise.context.ApplicationScoped;
import org.eclipse.microprofile.health.HealthCheck;
import org.eclipse.microprofile.health.HealthCheckResponse;
import org.eclipse.microprofile.health.Liveness;

import java.util.Random;

@Liveness <1>
@ApplicationScoped <2>
public class LivenessCheck implements HealthCheck { <3>
    @Override
    public HealthCheckResponse call() {
        boolean isUp = new Random().nextBoolean(); <4>

        if(isUp) { <5>
            return HealthCheckResponse.up("liveness-check");
        } else {
            return HealthCheckResponse.down("liveness-check");
        }
    }
}

----
<1> `@Liveness` annotation means that the check is a Liveness-Check and exposes the result on `/q/health/live`.
<2> Itâ€™s recommended to annotate the health check class with `@ApplicationScoped` so that a single bean instance is used for all health check requests.
<3> Your health check class needs to implement the `HealthCheck` interface.
<4> This is the condition whether the check is up or down. Here in the demo example we use a random boolean
<5> Here you return the name of your health check with `HealthCheckResponse.up` or `HealthCheckResponse.down`

==== Get response of LivenessCheck

.Accumulating all health check procedures in the application
[source, bash]
----
curl http://localhost:8080/q/health/live
----

.Response of /q/health/live
[source, json]
----
{
    "status": "DOWN",
    "checks": [
        {
            "name": "liveness-check",
            "status": "DOWN"
        }
    ]
}
----